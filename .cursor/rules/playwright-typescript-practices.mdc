---
description: "Playwright + TypeScript best practices"
globs: "**/*.{spec,test,e2e}.ts"
alwaysApply: true
---

# Playwright (TypeScript) Best Practices

- Always use MCP to discover page structure and verify locators before writing tests.
- Prefer stable locators (in order): `id`, `name`, `data-testid`, then accessible roles/labels. Avoid guessing selectors.
- Do not perform extra actions in tests beyond what's required for the assertion. Keep each test focused on a single behavior.
- Avoid arbitrary timeouts (`page.waitForTimeout`). Prefer:
  - `await expect(locator).toBeVisible()` (built-in retries),
  - `await locator.waitFor({ state: 'visible' })`,
  - `await page.waitForResponse(...)` or `await page.waitForURL(...)` when verifying navigation.
- Do not use deprecated APIs such as `page.waitForNavigation(...)`. Use `page.waitForURL(...)`, `locator.waitFor(...)`, `waitForResponse`, or pair the click with an explicit wait:

```ts
await Promise.all([
  page.getByRole('button', { name: 'Log in' }).click(),
  page.waitForURL('/'),
]);
```

or

```ts
await page.getByRole('button', { name: 'Log in' }).click();
await page.getByRole('link', { name: 'My account' }).waitFor({ state: 'visible' });
```

- When asserting a post-action state, prefer asserting a single stable element (e.g., `My account` link or a unique account display name) rather than multiple checks.
- Keep tests minimal and deterministic: fill only required fields, click the submit control, and assert a single post-condition.
- Use MCP Playwright tools (e.g., `browser_snapshot`, `browser_run_code`) to capture the DOM and confirm ids/labels before coding tests.
- If a flow requires authentication for many tests, capture `storageState` once in a fixture and reuse it via `test.use({ storageState: 'tests/state/auth.json' })`.
- Prefer explicit, descriptive test names (e.g., `test('login', ...)` or `test('user can log in')`) and keep one expectation per logical behavior.

- Environment & secrets
- Use `dotenv` (devDependency) to manage environment-specific values (credentials, base URL, feature flags). Add a `.env.example` with placeholder values and add `.env` to `.gitignore`. Never commit real credentials.
- Do not hardcode sensitive values in tests or rules. Tests should read values from `process.env` and fail fast if required variables are missing:

```ts
// tests/login.spec.ts
import dotenv from 'dotenv';
dotenv.config();
const EMAIL = process.env.TEST_EMAIL;
if (!EMAIL) throw new Error('Missing TEST_EMAIL');
```

- Extract `baseURL` to env and load it in `playwright.config.ts` (use `process.env.BASE_URL ?? '<default>'`), so tests don't depend on a single hardcoded host.

- Visible / unique element selection
- When a selector can match multiple elements (including hidden duplicates), prefer targeting visible instances or narrow using `hasText` + `.first()`:

```ts
await expect(page.locator('a[href="/customer/info"]:visible').first()).toBeVisible();
```

## Page Object Model (POM)

- Organize page objects under `tests/pages/` and name classes after pages (e.g., `LoginPage`, `HomePage`).
- Page objects should encapsulate behavior and waits. Tests should call high-level actions (e.g., `loginPage.login(email, pwd)`) and perform assertions â€” do not duplicate low-level waits in tests.
- Encapsulate waits inside page-object methods. Example:

```ts
// tests/pages/LoginPage.ts
async login(email: string, pwd: string) {
  await this.username.fill(email);
  await this.password.fill(pwd);
  await Promise.all([this.loginButton.click(), this.page.waitForURL('/')]);
  // internal visibility wait ensures the method only returns when logged in
  await this.myAccountLink.waitFor({ state: 'visible' });
}
```

- Do NOT expose separate public `waitForX()` helpers for common flows that are already awaited inside action methods. If a wait helper is necessary for reuse, make it private (prefix with `_`) or keep it internal.
- Keep page objects minimal: provide only the actions tests need and helpers that return values (e.g., `getResultsCount()`).
- Page objects should avoid assertions; let tests assert outcomes.

## Fixtures & test setup

- Provide page objects and common test utilities via Playwright fixtures. Place fixture definitions in `tests/fixtures.ts` and export `{ test, expect }` from there so tests can import your extended `test`.
- Fixture responsibilities:
  - Create and expose page-object instances (e.g., `loginPage`, `homePage`).
  - Configure and reuse `storageState` for authenticated flows when needed.
  - Provide shared helpers (e.g., `apiClient`, `dbReset`) if required by many tests.
- Example `tests/fixtures.ts`:

```ts
import { test as base, expect } from '@playwright/test';
import { LoginPage } from './pages/LoginPage';
import { HomePage } from './pages/HomePage';

type Pages = { loginPage: LoginPage; homePage: HomePage };

export const test = base.extend<Pages>({
  loginPage: async ({ page }, use) => { await use(new LoginPage(page)); },
  homePage: async ({ page }, use) => { await use(new HomePage(page)); },
});
export { expect };
```

- Example test usage:

```ts
import { test, expect } from './fixtures';

test('login', async ({ loginPage }) => {
  await loginPage.goto();
  await loginPage.login(process.env.TEST_EMAIL!, process.env.TEST_PASSWORD!);
  await expect(loginPage.myAccountLink).toBeVisible();
});
```

- Keep fixtures minimal and focused; avoid putting test assertions inside fixtures. Fixtures should prepare state, not validate it.

## Artifacts, Tracing & Video

- Configure recording in `playwright.config.ts` thoughtfully:
  - For daily development: `trace: 'on'`, `video: 'on'` will always record but increase disk usage.
  - For CI: prefer `trace: 'on-first-retry'` and `video: 'retain-on-failure'`.
- Use CLI `--trace=on` to force trace for a single run. There is no CLI `--video` flag; enable video via config or programmatically.
- To programmatically capture trace around a block:

```ts
await page.context().tracing.start({ screenshots: true, snapshots: true });
// actions...
await page.context().tracing.stop({ path: 'trace.zip' });
```

- Artifacts are stored under `outputDir` (e.g., `playwright-report`). Use `npx playwright show-report` to view them in the browser.

## Environment & Secrets (reiterated)

- Use `dotenv` to load env values in tests and config. Provide `.env.example` with placeholders and add `.env` to `.gitignore`.
- Tests should fail fast when required env vars are missing (throw during test file load).



## Examples

```typescript
import { test, expect } from '@playwright/test';

test('login', async ({ page }) => {
  await page.goto('/login');
  await page.fill('#UsernameOrEmail', 'tester+testowy@gmail.com');
  await page.fill('#Password', 'test123');
  await page.getByRole('button', { name: 'Log in' }).click();
  await expect(page.getByRole('link', { name: 'My account' })).toBeVisible();
});
```

```typescript
// playwright.config.ts
import { defineConfig } from '@playwright/test';
export default defineConfig({
  testDir: 'tests',
  timeout: 30_000,
  // Adjust retries as needed for flaky infra; keep tests themselves deterministic.
  retries: 0,
  use: { headless: true, trace: 'on-first-retry', actionTimeout: 10_000 },
});
```

